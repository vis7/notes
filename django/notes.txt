# custom filter
- Define function with decorator like below
```
from django import template

register = template.Library()

@register.filter(name='cut')
def cut(value, arg):
    return value.replace(arg, '')
```
- Now you can use it in template like below.
```
{{variable|cut}}
```

# formset
We can handle multiple object of same model class using formset. ie. we can take multiple article from user simulteneously
```
from django.forms import formset_factory

# creating a formset and 5 instances of GeeksForm
GeeksFormSet = formset_factory(GeeksForm, extra = 5) # GeekForm is normal form whose 5 instance will be created
formset = GeeksFormSet() # we can now use it as normal form
```

# authentication
https://studygyaan.com/django/how-to-extend-django-user-model


#
- To dump data:
```
python manage.py dumpdata app.model_name --indent 4 > fixtures/model_name.json
```
- To load data:
```
python manage.py loaddata fixtures/model_name.json --app app.model_name
```

- force login user
self.client.force_login(user1)
self.client.login(username='user1', password='Use@1234')

- In django test objects created are stay only in that function (test case). In other function that are not available.


# Permission
Token Authentication
from rest_framework.authtoken import views
urlpatterns += [
    path('api-token-auth/', views.obtain_auth_token)
]

f successfully authenticated, TokenAuthentication provides the following credentials.

request.user will be a Django User instance.
request.auth will be a rest_framework.authtoken.models.Token instance.

Unauthenticated responses that are denied permission will result in an HTTP 401 Unauthorized response with an appropriate WWW-Authenticate header.

login - authentication
roles - authorization


from rest_framework import permissions

class BlocklistPermission(permissions.BasePermission):
    """
    Global permission check for blocked IPs.
    """

    def has_permission(self, request, view):
        ip_addr = request.META['REMOTE_ADDR']
        blocked = Blocklist.objects.filter(ip_addr=ip_addr).exists()
        return not blocked

class IsOwnerOrReadOnly(permissions.BasePermission):
    """
    Object-level permission to only allow owners of an object to edit it.
    Assumes the model instance has an `owner` attribute.
    """

    def has_object_permission(self, request, view, obj):
        # Read permissions are allowed to any request,
        # so we'll always allow GET, HEAD or OPTIONS requests.
        if request.method in permissions.SAFE_METHODS:
            return True

        # Instance must have an attribute named `owner`.
        return obj.owner == request.user



# to start ngrok
ngrok http 8000

# General
+ https://stackoverflow.com/questions/31038742/pass-request-context-to-serializer-from-viewset-in-django-rest-framework
+ first validate_field run then validate method run

token = Token.objects.get_or_create(user=request.user)[0].key




- first values will be store in db, second will be shown to users
MANIFEST_TYPES = (
    (LOCAL, 'Local'),
    (INTER_BRANCH, 'Inter Branch')
)

# Meta inner class in Django models:
This is just a class container with some options (metadata) attached to the model. It defines such things as available permissions, associated database table name, whether the model is abstract or not, singular and plural versions of the name etc.
https://docs.djangoproject.com/en/5.0/ref/models/options/


```
- to remove all migrations # use powershell
find . -path "*/migrations/*.py" -not -name "__init__.py" -delete
find . -path "*/migrations/*.pyc"  -delete
```

# Learn
- orm
- signals
- middleware
- cache

- celery
- rabbitmq
- stripe


# notes
- User is able to login only if it is active
- form_valid method is overridden in view rather then form



+ when we have  many to many field using through table, when we do entry in in model using add() or remove(), its respective effect on through table will also be done by django.

order_ids = request.data.get("orders", [])
orders = Order.objects.filter(id__in=order_ids)
order_list = [order for order in orders]

bag.orders.add(*order_list)


- reverse vs reverse_lazy
In summary, use reverse for generating URLs in views when the URL is needed immediately and reverse_lazy for generating URLs in situations where accessing the URL immediately may cause issues or where lazy evaluation is preferred.
eg. 

class MyRedirectView(RedirectView):
    url = reverse_lazy('some_url_name') # evaluated immediately so used reverse_lazy

